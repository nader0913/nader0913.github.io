<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Article Builder</title>
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/article.css">
    <link rel="stylesheet" href="css/builder.css">
    <!-- MathJax for LaTeX support -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
    <!-- Exact same structure as article page -->
    <div id="post-content" style="display: block;">
        <div class="article-top-navigation">
            <a href="#" class="back-link" onclick="goBack()">&larr; Back</a>
            <div class="article-chapter" contenteditable="true" data-placeholder="Chapter">Chapter</div>
            <div class="article-date" contenteditable="true" data-placeholder="Date">Dec 25, 2024</div>
        </div>

        <div class="article-title" contenteditable="true" data-placeholder="Article Title">Article Title</div>

        <div id="markdown-output">
            <!-- Component buttons will be inserted here dynamically -->
        </div>

        <div class="article-bottom-navigation">
            <a href="#" onclick="exportArticle()">&larr; Export</a>
            <a href="#" onclick="clearAll()">Clear &rarr;</a>
        </div>
    </div>

    <script>
        class ArticleBuilder {
            constructor() {
                this.content = document.getElementById('markdown-output');
                this.componentCounter = 0;
                this.setupEventListeners();
                this.addDeleteButtonsToExistingComponents();
                this.createComponentButtons();
                this.createFormattingToolbar();
                this.loadDraft();
                this.setupAutoSave();
            }

            setupEventListeners() {
                // Handle focus/blur for editing mode
                document.addEventListener('focusin', (e) => {
                    if (e.target.contentEditable === 'true') {
                        e.target.classList.add('editing');

                        // Add editing-child class to parent component
                        const component = e.target.closest('.builder-component');
                        if (component) {
                            component.classList.add('editing-child');
                        }

                        // Clear placeholder text on first focus
                        if (e.target.hasAttribute('data-is-placeholder')) {
                            e.target.textContent = '';
                            e.target.removeAttribute('data-is-placeholder');
                        }
                    }
                });

                document.addEventListener('focusout', (e) => {
                    if (e.target.contentEditable === 'true') {
                        e.target.classList.remove('editing');
                        
                        // Remove editing-child class from parent component
                        const component = e.target.closest('.builder-component');
                        if (component) {
                            component.classList.remove('editing-child');
                        }
                        
                        // Add delay before hiding toolbar to allow for toolbar button clicks
                        setTimeout(() => {
                            // Only hide if focus is not on the toolbar
                            if (!document.activeElement || !document.activeElement.closest('.formatting-toolbar')) {
                                this.hideFormattingToolbar();
                            }
                        }, 100);
                        
                        this.processContent(e.target);

                        // Check if component should be auto-deleted
                        if (e.target.textContent.trim() === '') {
                            // Check if this is the only component
                            const allComponents = this.content.querySelectorAll('.builder-component:not(.component-buttons)');
                            if (allComponents.length > 1) {
                                // Ask for confirmation before deleting
                                setTimeout(() => {
                                    if (confirm('This component is empty. Delete it?')) {
                                        this.removeComponent(component);
                                    } else {
                                        // Restore placeholder if user chooses not to delete
                                        e.target.textContent = e.target.dataset.placeholder;
                                        e.target.setAttribute('data-is-placeholder', 'true');
                                    }
                                }, 100);
                            } else {
                                // If it's the last component, just restore placeholder
                                e.target.textContent = e.target.dataset.placeholder;
                                e.target.setAttribute('data-is-placeholder', 'true');
                            }
                        }
                    }
                });

                // Handle paste events to strip formatting
                document.addEventListener('paste', (e) => {
                    if (e.target.contentEditable === 'true') {
                        e.preventDefault();
                        
                        // Get plain text from clipboard
                        const text = (e.clipboardData || window.clipboardData).getData('text');
                        
                        // Insert plain text at cursor position
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0);
                            range.deleteContents();
                            range.insertNode(document.createTextNode(text));
                            range.collapse(false);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }
                        
                        // Clear placeholder if it exists
                        if (e.target.hasAttribute('data-is-placeholder')) {
                            e.target.removeAttribute('data-is-placeholder');
                        }
                    }
                });

                // Handle keyboard shortcuts for formatting and list functionality
                document.addEventListener('keydown', (e) => {
                    if (e.target.contentEditable === 'true') {
                        // Handle Enter key in list items
                        if (e.key === 'Enter' && e.target.tagName === 'LI') {
                            e.preventDefault();
                            const list = e.target.parentElement;
                            const listType = list.tagName.toLowerCase();
                            this.handleListEnter(e.target, listType);
                            return;
                        }
                        
                        // Ctrl/Cmd + B for bold
                        if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
                            e.preventDefault();
                            this.toggleFormat('bold');
                            this.updateFormattingButtons();
                        }
                        // Ctrl/Cmd + I for italic
                        else if ((e.ctrlKey || e.metaKey) && e.key === 'i') {
                            e.preventDefault();
                            this.toggleFormat('italic');
                            this.updateFormattingButtons();
                        }
                        // Ctrl/Cmd + U for underline
                        else if ((e.ctrlKey || e.metaKey) && e.key === 'u') {
                            e.preventDefault();
                            this.toggleFormat('underline');
                            this.updateFormattingButtons();
                        }
                    }
                });

                // Handle text selection for formatting toolbar
                document.addEventListener('selectionchange', () => {
                    this.handleSelectionChange();
                });

                // Hide toolbar when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.formatting-toolbar') && !e.target.closest('[contenteditable="true"]')) {
                        this.hideFormattingToolbar();
                    }
                });
            }

            addDeleteButtonsToExistingComponents() {
                // This method is no longer needed - components auto-delete when empty
            }

            createFormattingToolbar() {
                this.formattingToolbar = document.createElement('div');
                this.formattingToolbar.className = 'formatting-toolbar';
                this.formattingToolbar.innerHTML = `
                    <button class="format-btn" data-format="bold" title="Bold (Ctrl+B)"><strong>B</strong></button>
                    <button class="format-btn" data-format="italic" title="Italic (Ctrl+I)"><em>I</em></button>
                    <button class="format-btn" data-format="underline" title="Underline (Ctrl+U)"><u>U</u></button>
                `;

                // Add event listeners to format buttons
                this.formattingToolbar.querySelectorAll('.format-btn').forEach(btn => {
                    btn.addEventListener('mousedown', (e) => {
                        e.preventDefault(); // Prevent focus change
                    });
                    
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const format = e.currentTarget.dataset.format;
                        this.toggleFormat(format);
                        this.updateFormattingButtons();
                        
                        // Keep selection and toolbar visible
                        setTimeout(() => {
                            this.showFormattingToolbar();
                        }, 10);
                    });
                });

                document.body.appendChild(this.formattingToolbar);
            }

            createComponentButtons() {
                // Check if buttons already exist
                if (this.content.querySelector('.component-buttons')) {
                    return; // Don't create duplicates
                }

                const buttons = document.createElement('div');
                buttons.className = 'component-buttons';
                buttons.innerHTML = `
                    <button class="component-btn" data-component="paragraph" title="Add Paragraph">¶</button>
                    <button class="component-btn" data-component="header" title="Add Header">H1</button>
                    <button class="component-btn" data-component="subheader" title="Add Subheader">H2</button>
                    <button class="component-btn" data-component="subsubheader" title="Add Subsubheader">H3</button>
                    <button class="component-btn" data-component="blockquote" title="Add Quote">"</button>
                    <button class="component-btn" data-component="unordered-list" title="Add Unordered List">•</button>
                    <button class="component-btn" data-component="ordered-list" title="Add Ordered List">1.</button>
                    <button class="component-btn" data-component="image" title="Add Image">📷</button>
                    <button class="component-btn" data-component="math" title="Add Math">∑</button>
                    <button class="component-btn" data-component="table" title="Add Table">⊞</button>
                    <button class="component-btn" data-component="divider" title="Add Divider">—</button>
                `;

                // Add event listeners to buttons
                buttons.querySelectorAll('.component-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const component = e.currentTarget.dataset.component;
                        this.addComponent(component);
                    });
                });

                this.content.appendChild(buttons);
            }

            addComponent(type) {
                const id = `component-${++this.componentCounter}`;
                let element;

                switch (type) {
                    case 'paragraph':
                        element = this.createEditableElement('div', 'article-paragraph', 'Start writing...');
                        break;
                    case 'header':
                        element = this.createEditableElement('div', 'article-header', 'Header text');
                        break;
                    case 'subheader':
                        element = this.createEditableElement('div', 'article-subheader', 'Subheader text');
                        break;
                    case 'subsubheader':
                        element = this.createEditableElement('div', 'article-subsubheader', 'Subsubheader text');
                        break;
                    case 'blockquote':
                        element = this.createEditableElement('div', 'article-blockquote', 'Quote text...');
                        break;
                    case 'unordered-list':
                        element = this.createList('ul');
                        break;
                    case 'ordered-list':
                        element = this.createList('ol');
                        break;
                    case 'image':
                        element = this.createImage();
                        break;
                    case 'math':
                        element = this.createMath();
                        break;
                    case 'table':
                        element = this.createTable();
                        break;
                    case 'divider':
                        element = document.createElement('div');
                        element.className = 'article-divider';
                        break;
                }

                if (element) {
                    element.id = id;
                    element.classList.add('builder-component');

                    // Add reorder controls
                    this.addReorderControlsToComponent(element);

                    // Insert before component buttons
                    const buttons = this.content.querySelector('.component-buttons');
                    this.content.insertBefore(element, buttons);

                    // Focus on editable elements
                    const editable = element.querySelector('[contenteditable="true"]') ||
                        (element.contentEditable === 'true' ? element : null);
                    if (editable) {
                        editable.focus();
                    }

                    // Auto-save after adding component
                    this.saveDraft();

                    // Update reorder button states
                    this.updateReorderButtonStates();
                }
            }

            createEditableElement(tag, className, placeholder) {
                const element = document.createElement(tag);
                element.className = className;
                element.contentEditable = true;
                element.dataset.placeholder = placeholder;
                element.textContent = placeholder;
                element.setAttribute('data-is-placeholder', 'true');
                return element;
            }

            createList(listType = 'ul') {
                const wrapper = document.createElement('div');
                wrapper.className = 'article-list';

                const list = document.createElement(listType);
                const li = document.createElement('li');
                li.contentEditable = true;
                li.dataset.placeholder = 'List item...';
                li.textContent = 'List item...';
                li.setAttribute('data-is-placeholder', 'true');

                list.appendChild(li);
                wrapper.appendChild(list);
                return wrapper;
            }

            createImage() {
                const wrapper = document.createElement('div');
                wrapper.className = 'article-image';

                const img = document.createElement('img');
                img.src = 'https://via.placeholder.com/600x300?text=Click+to+change+image';
                img.alt = 'Placeholder image';
                img.addEventListener('click', () => {
                    const url = prompt('Enter image URL:', img.src);
                    if (url) img.src = url;
                });

                const caption = document.createElement('p');
                caption.contentEditable = true;
                caption.dataset.placeholder = 'Image caption...';
                caption.textContent = 'Image caption...';
                caption.setAttribute('data-is-placeholder', 'true');

                wrapper.appendChild(img);
                wrapper.appendChild(caption);
                return wrapper;
            }

            createMath() {
                const element = document.createElement('div');
                element.className = 'article-math-display';
                element.contentEditable = true;
                element.dataset.placeholder = 'Enter LaTeX: e.g., $$E = mc^2$$';
                element.textContent = '$$E = mc^2$$';
                element.setAttribute('data-is-placeholder', 'true');

                element.addEventListener('blur', () => {
                    if (window.MathJax) {
                        MathJax.typesetPromise([element]);
                    }
                });

                return element;
            }

            createTable() {
                const table = document.createElement('table');
                table.className = 'article-table';

                // Create header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                for (let i = 0; i < 3; i++) {
                    const th = document.createElement('th');
                    th.contentEditable = true;
                    th.textContent = `Header ${i + 1}`;
                    th.dataset.placeholder = `Header ${i + 1}`;
                    th.setAttribute('data-is-placeholder', 'true');
                    headerRow.appendChild(th);
                }
                thead.appendChild(headerRow);

                // Create body
                const tbody = document.createElement('tbody');
                for (let i = 0; i < 2; i++) {
                    const row = document.createElement('tr');
                    for (let j = 0; j < 3; j++) {
                        const td = document.createElement('td');
                        td.contentEditable = true;
                        td.textContent = `Cell ${i + 1},${j + 1}`;
                        td.dataset.placeholder = `Cell ${i + 1},${j + 1}`;
                        td.setAttribute('data-is-placeholder', 'true');
                        row.appendChild(td);
                    }
                    tbody.appendChild(row);
                }

                table.appendChild(thead);
                table.appendChild(tbody);
                return table;
            }

            processContent(element) {
                // Handle special processing like math
                if (element.classList.contains('article-math-display')) {
                    if (window.MathJax) {
                        MathJax.typesetPromise([element]);
                    }
                }
            }


            toggleFormat(format) {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return;

                const range = selection.getRangeAt(0);
                if (range.collapsed) return; // No text selected

                // Check if the selection is already formatted
                const selectedText = range.toString();
                const container = range.commonAncestorContainer;
                
                // Get the parent element if we're in a text node
                const parentElement = container.nodeType === Node.TEXT_NODE ? 
                    container.parentElement : container;

                let formattedElement;
                
                switch (format) {
                    case 'bold':
                        formattedElement = this.findFormattingElement(parentElement, ['B', 'STRONG']);
                        if (formattedElement && range.intersectsNode(formattedElement)) {
                            // Remove bold formatting
                            this.unwrapFormat(formattedElement);
                        } else {
                            // Add bold formatting
                            this.wrapSelection('strong');
                        }
                        break;
                    case 'italic':
                        formattedElement = this.findFormattingElement(parentElement, ['I', 'EM']);
                        if (formattedElement && range.intersectsNode(formattedElement)) {
                            // Remove italic formatting
                            this.unwrapFormat(formattedElement);
                        } else {
                            // Add italic formatting
                            this.wrapSelection('em');
                        }
                        break;
                    case 'underline':
                        formattedElement = this.findFormattingElement(parentElement, ['U']);
                        if (formattedElement && range.intersectsNode(formattedElement)) {
                            // Remove underline formatting
                            this.unwrapFormat(formattedElement);
                        } else {
                            // Add underline formatting
                            this.wrapSelection('u');
                        }
                        break;
                }
            }

            findFormattingElement(element, tagNames) {
                let current = element;
                while (current && current !== document.body) {
                    if (tagNames.includes(current.tagName)) {
                        return current;
                    }
                    current = current.parentElement;
                }
                return null;
            }

            wrapSelection(tagName) {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return;

                const range = selection.getRangeAt(0);
                const wrapper = document.createElement(tagName);
                
                try {
                    range.surroundContents(wrapper);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } catch (e) {
                    // If surroundContents fails, extract and wrap manually
                    const contents = range.extractContents();
                    wrapper.appendChild(contents);
                    range.insertNode(wrapper);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }

            unwrapFormat(element) {
                const parent = element.parentNode;
                while (element.firstChild) {
                    parent.insertBefore(element.firstChild, element);
                }
                parent.removeChild(element);
                
                // Merge adjacent text nodes
                parent.normalize();
            }

            handleSelectionChange() {
                const selection = window.getSelection();
                
                // Don't hide toolbar immediately if we're interacting with it
                if (document.activeElement && document.activeElement.closest('.formatting-toolbar')) {
                    return;
                }
                
                if (selection.rangeCount === 0 || selection.isCollapsed) {
                    // Add small delay to prevent hiding when clicking toolbar buttons
                    setTimeout(() => {
                        if (!document.activeElement || !document.activeElement.closest('.formatting-toolbar')) {
                            this.hideFormattingToolbar();
                        }
                    }, 10);
                    return;
                }

                const range = selection.getRangeAt(0);
                const container = range.commonAncestorContainer;
                const element = container.nodeType === Node.TEXT_NODE ? 
                    container.parentElement : container;

                // Only show toolbar if selection is within contenteditable element
                const editableParent = element.closest('[contenteditable="true"]');
                if (!editableParent) {
                    this.hideFormattingToolbar();
                    return;
                }

                this.showFormattingToolbar();
                this.updateFormattingButtons();
            }

            showFormattingToolbar() {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return;

                const range = selection.getRangeAt(0);
                const rect = range.getBoundingClientRect();
                
                if (rect.width === 0 && rect.height === 0) {
                    this.hideFormattingToolbar();
                    return;
                }

                // Position toolbar above the selection
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                
                this.formattingToolbar.style.top = (rect.top + scrollTop - 40) + 'px';
                this.formattingToolbar.style.left = (rect.left + scrollLeft + (rect.width / 2) - 50) + 'px';
                
                this.formattingToolbar.classList.add('show');
            }

            hideFormattingToolbar() {
                this.formattingToolbar.classList.remove('show');
            }

            updateFormattingButtons() {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return;

                const range = selection.getRangeAt(0);
                const container = range.commonAncestorContainer;
                const element = container.nodeType === Node.TEXT_NODE ? 
                    container.parentElement : container;

                // Check current formatting state
                const formats = {
                    bold: this.findFormattingElement(element, ['B', 'STRONG']) !== null,
                    italic: this.findFormattingElement(element, ['I', 'EM']) !== null,
                    underline: this.findFormattingElement(element, ['U']) !== null
                };

                // Update button states
                this.formattingToolbar.querySelectorAll('.format-btn').forEach(btn => {
                    const format = btn.dataset.format;
                    btn.classList.toggle('active', formats[format] || false);
                });
            }

            handleListEnter(currentLi, listType) {
                // If the current list item is empty, remove it and exit the list
                if (currentLi.textContent.trim() === '' || currentLi.hasAttribute('data-is-placeholder')) {
                    const listWrapper = currentLi.closest('.article-list');
                    const list = currentLi.parentElement;
                    
                    // If this is the only list item, remove the entire list component
                    if (list.children.length === 1) {
                        const component = listWrapper.closest('.builder-component');
                        this.removeComponent(component);
                        return;
                    }
                    
                    // Remove the empty list item and exit
                    currentLi.remove();
                    return;
                }

                // Create a new list item
                const newLi = document.createElement('li');
                newLi.contentEditable = true;
                newLi.dataset.placeholder = 'List item...';
                newLi.textContent = 'List item...';
                newLi.setAttribute('data-is-placeholder', 'true');

                // Insert the new list item after the current one
                const list = currentLi.parentElement;
                if (currentLi.nextSibling) {
                    list.insertBefore(newLi, currentLi.nextSibling);
                } else {
                    list.appendChild(newLi);
                }

                // Focus on the new list item
                newLi.focus();
                
                // Clear placeholder text on focus
                if (newLi.hasAttribute('data-is-placeholder')) {
                    newLi.textContent = '';
                    newLi.removeAttribute('data-is-placeholder');
                }
            }

            removeComponent(component) {
                // Add removing animation class
                component.classList.add('removing');

                // Remove after animation completes
                setTimeout(() => {
                    component.remove();
                    this.saveDraft(); // Auto-save after removing component
                    this.updateReorderButtonStates(); // Update button states after removal
                }, 200);
            }

            loadDraft() {
                const draft = localStorage.getItem('article-builder-draft');
                if (draft) {
                    try {
                        const data = JSON.parse(draft);
                        
                        // Load article metadata
                        if (data.title) {
                            document.querySelector('.article-title').textContent = data.title;
                        }
                        if (data.chapter) {
                            document.querySelector('.article-chapter').textContent = data.chapter;
                        }
                        if (data.date) {
                            document.querySelector('.article-date').textContent = data.date;
                        }

                        // Load content
                        if (data.content) {
                            this.content.innerHTML = data.content;
                            // Re-add component buttons at the end
                            this.createComponentButtons();
                            // Set component counter to avoid ID conflicts
                            this.componentCounter = data.componentCounter || 0;
                            // Re-add reorder controls to existing components
                            this.addReorderControls();
                            // Update button states
                            this.updateReorderButtonStates();
                        }
                    } catch (e) {
                        console.warn('Failed to load draft:', e);
                    }
                }
            }

            saveDraft() {
                try {
                    const data = {
                        title: document.querySelector('.article-title').textContent,
                        chapter: document.querySelector('.article-chapter').textContent,
                        date: document.querySelector('.article-date').textContent,
                        content: this.content.innerHTML,
                        componentCounter: this.componentCounter,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('article-builder-draft', JSON.stringify(data));
                } catch (e) {
                    console.warn('Failed to save draft:', e);
                }
            }

            setupAutoSave() {
                // Auto-save on content changes
                let saveTimeout;
                const debouncedSave = () => {
                    clearTimeout(saveTimeout);
                    saveTimeout = setTimeout(() => this.saveDraft(), 1000); // Save 1 second after last change
                };

                // Save on input/paste/etc
                document.addEventListener('input', debouncedSave);
                document.addEventListener('paste', debouncedSave);
            }

            addReorderControlsToComponent(component) {
                // Don't add if already exists
                if (component.querySelector('.reorder-controls')) {
                    return;
                }

                // CSS handles positioning via .builder-component class

                // Create reorder controls container
                const reorderControls = document.createElement('div');
                reorderControls.className = 'reorder-controls';
                reorderControls.innerHTML = `
                    <button class="reorder-btn up" title="Move Up" data-direction="up">↑</button>
                    <button class="reorder-btn down" title="Move Down" data-direction="down">↓</button>
                `;

                // Add event listeners
                reorderControls.querySelectorAll('.reorder-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const direction = e.currentTarget.dataset.direction;
                        this.moveComponent(component, direction);
                    });
                });

                // Append to the component (not insert at beginning)
                component.appendChild(reorderControls);
            }

            addReorderControls() {
                // Add reorder controls to all existing components
                const components = this.content.querySelectorAll('.builder-component:not(.component-buttons)');
                components.forEach(component => {
                    // Only add if not already present
                    if (!component.querySelector('.reorder-controls')) {
                        this.addReorderControlsToComponent(component);
                    }
                });
            }

            moveComponent(component, direction) {
                const components = Array.from(this.content.querySelectorAll('.builder-component:not(.component-buttons)'));
                const currentIndex = components.indexOf(component);
                
                if (direction === 'up' && currentIndex > 0) {
                    // Move up - insert current component before the previous one
                    const previousComponent = components[currentIndex - 1];
                    this.content.insertBefore(component, previousComponent);
                } else if (direction === 'down' && currentIndex < components.length - 1) {
                    // Move down - insert current component after the next one
                    const nextComponent = components[currentIndex + 1];
                    if (nextComponent.nextSibling) {
                        this.content.insertBefore(component, nextComponent.nextSibling);
                    } else {
                        // Insert before component buttons if nextComponent is the last one
                        const buttons = this.content.querySelector('.component-buttons');
                        this.content.insertBefore(component, buttons);
                    }
                }

                // Update reorder button states
                this.updateReorderButtonStates();
                
                // Auto-save after reordering
                this.saveDraft();
            }

            updateReorderButtonStates() {
                const components = Array.from(this.content.querySelectorAll('.builder-component:not(.component-buttons)'));
                
                components.forEach((component, index) => {
                    const controls = component.querySelector('.reorder-controls');
                    if (!controls) return; // Skip if no controls
                    
                    const upBtn = controls.querySelector('.reorder-btn.up');
                    const downBtn = controls.querySelector('.reorder-btn.down');
                    
                    if (upBtn) {
                        upBtn.disabled = (index === 0);
                        upBtn.style.opacity = upBtn.disabled ? '0.3' : '1';
                    }
                    if (downBtn) {
                        downBtn.disabled = (index === components.length - 1);
                        downBtn.style.opacity = downBtn.disabled ? '0.3' : '1';
                    }
                });
            }
        }

        // Global functions for nav links
        function goBack() {
            if (confirm('Are you sure you want to go back? Unsaved changes will be lost.')) {
                window.history.back();
            }
        }

        function exportArticle() {
            const title = document.querySelector('.article-title').textContent;
            const date = document.querySelector('.article-date').textContent;
            const chapter = document.querySelector('.article-chapter').textContent;

            // Get content without component buttons
            const content = document.getElementById('markdown-output').cloneNode(true);
            const buttons = content.querySelector('.component-buttons');
            if (buttons) buttons.remove();

            const html = `
<div id="post-content">
    <div class="article-top-navigation">
        <a href="#" class="back-link">&larr; Back</a>
        <div class="article-chapter">${chapter}</div>
        <div class="article-date">${date}</div>
    </div>
    <div class="article-title">${title}</div>
    <div id="markdown-output">
        ${content.innerHTML}
    </div>
    <div class="article-bottom-navigation">
        <a href="#">&larr; Previous</a>
        <a href="#">Next &rarr;</a>
    </div>
</div>`;

            // Create and download file
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'article.html';
            a.click();
            URL.revokeObjectURL(url);
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all content? This will also delete your saved draft.')) {
                // Clear localStorage
                localStorage.removeItem('article-builder-draft');
                
                const content = document.getElementById('markdown-output');
                content.innerHTML = '';

                document.querySelector('.article-title').textContent = 'Article Title';
                document.querySelector('.article-date').textContent = 'Dec 25, 2024';
                document.querySelector('.article-chapter').textContent = 'Chapter';

                // Recreate component buttons
                const builder = new ArticleBuilder();
            }
        }

        // Initialize the builder when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new ArticleBuilder();
        });

        // Configure MathJax
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
</body>

</html>